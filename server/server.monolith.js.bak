/**
 * wikiflow server - å•æ–‡ä»¶åç«¯
 * - ç«¯å£ 4000
 * - æœ¬åœ°ç™»å½•ï¼ˆbcrypt + cookie-sessionï¼‰
 * - CSRF åŒæäº¤æ ¡éªŒ
 * - SQLite è®°å½•ï¼šç”¨æˆ·ã€ç™»å½•æ—¥å¿—ã€æ“ä½œæ—¥å¿—ã€é˜Ÿåˆ—ã€ç”¨æˆ·è®¾ç½®ï¼ˆå«åŠ å¯†å­˜ tokenï¼‰
 * - å¯¹æ¥ Wiki.js GraphQL APIï¼šæ£€æµ‹é‡å¤ã€åˆ›å»º/è¦†ç›–é¡µé¢
 * - æç®€ä¾èµ–ï¼Œå°½é‡çœå†…å­˜
 */
'use strict';
const express = require('express');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cookieSession = require('cookie-session');
const bcrypt = require('bcrypt');
const Database = require('better-sqlite3');
const crypto = require('crypto');
const path = require('path');
const fs = require('fs');

const {
  PORT,
  DB_PATH,
  NODE_ENV,
  SESSION_SECRET,
  APP_KEY,
  DEFAULT_WIKI_BASE,
  DEFAULT_WIKI_GRAPHQL,
  DEFAULT_LOCALE,
  DEFAULT_EDITOR,
  GQL_TIMEOUT_MS,
  BODY_LIMIT,
  WF_TTL_MS,
  WF_ALLOWED_ORIGINS,
  WF_PIN_FOCUS_THROTTLE_MS,
  WF_IDLE_TTL_MS,
  WF_MAX_TTL_MS,
  WF_ROTATE,
  WF_ROTATE_INTERVAL_MS,
} = require('./server-js/wf-server-config.js');


// ---------- å‡†å¤‡æ•°æ®ç›®å½• ----------
fs.mkdirSync(path.dirname(DB_PATH), { recursive: true });

// ---------- åˆå§‹åŒ– DB ----------
const db = new Database(DB_PATH);
db.pragma('journal_mode = WAL');
db.exec(`
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS user_settings (
  user_id INTEGER PRIMARY KEY,
  wiki_base_url TEXT,
  wiki_graphql_url TEXT,
  wiki_token_cipher TEXT,
  locale TEXT DEFAULT '${DEFAULT_LOCALE}',
  editor TEXT DEFAULT '${DEFAULT_EDITOR}',
  FOREIGN KEY(user_id) REFERENCES users(id)
);
CREATE TABLE IF NOT EXISTS login_events (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  ts DATETIME DEFAULT CURRENT_TIMESTAMP,
  ip TEXT,
  ua TEXT,
  FOREIGN KEY(user_id) REFERENCES users(id)
);
CREATE TABLE IF NOT EXISTS logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  ts DATETIME DEFAULT CURRENT_TIMESTAMP,
  action TEXT,
  details TEXT,
  FOREIGN KEY(user_id) REFERENCES users(id)
);
CREATE TABLE IF NOT EXISTS wf_slots (
  token TEXT PRIMARY KEY,
  user_id INTEGER NOT NULL,
  term_id INTEGER,               -- å¯ä¸ºç©ºï¼ˆä¸´æ—¶ç”Ÿæˆä¹Ÿè¡Œï¼‰
  title TEXT,                    -- è¯æ¡æ ‡é¢˜ï¼ˆç”¨äºé¢„è§ˆ/æäº¤ï¼‰
  text_in TEXT,                  -- æ¨¡æ¿ payload
  text_out TEXT,                 -- ç”Ÿæˆç»“æœï¼ˆæˆåŠŸæ—¶å­˜ï¼‰
  status TEXT DEFAULT 'waiting', -- waiting|picked|running|retrying|done|error
  error_msg TEXT,
  tries INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_wf_slots_user ON wf_slots(user_id);
CREATE TABLE IF NOT EXISTS terms (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  term TEXT NOT NULL,
  term_norm TEXT,       
  status TEXT DEFAULT 'new', -- new|submitted|posted
  title TEXT,
  tags_json TEXT,
  content TEXT,
  wiki_page_id INTEGER,
  wiki_path TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);
`);

// è¿ç§»ï¼šä¸ºè¿›åº¦æ¡å¢åŠ  progress åˆ—ï¼ˆå¦‚å·²å­˜åœ¨åˆ™å¿½ç•¥ï¼‰
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN progress INTEGER DEFAULT 0').run(); } catch (_) {}

// è¿ç§»ï¼šå¿ƒè·³å­—æ®µï¼ˆå¦‚å·²å­˜åœ¨åˆ™å¿½ç•¥ï¼‰
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN hb_last_at DATETIME').run(); } catch (_) {}
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN hb_rtt_ms INTEGER').run(); } catch (_) {}
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN hb_count INTEGER DEFAULT 0').run(); } catch (_){} 
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN pinned INTEGER DEFAULT 0').run(); } catch (_) {}

// å»ºè¡¨åé¢åŠ ä¸€æ¬¡æ€§è¿ç§»ï¼ˆæ”¾å’Œå…¶å®ƒ try ALTER ä¸€èµ·ï¼‰
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN opened_at DATETIME').run(); } catch (_) {}

// === è¡¥åˆ—ï¼ˆå¹‚ç­‰ï¼‰===
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN open_at_ms INTEGER').run(); } catch {}
try { db.prepare('ALTER TABLE wf_slots ADD COLUMN hb_last_at INTEGER').run(); } catch {}

// âœ… è¿ç§»ï¼šterms.term_norm + å”¯ä¸€ç´¢å¼•ï¼ˆuser_id, term_normï¼‰
try { db.prepare('ALTER TABLE terms ADD COLUMN term_norm TEXT').run(); } catch (_) {}
try {
  // å›å¡«å†å²æ•°æ®ï¼ˆä¸€æ¬¡æ€§ã€å¹‚ç­‰ï¼‰
  const norm = s => String(s||'').toLowerCase().replace(/\s+/g,'').trim();
  const rows = db.prepare('SELECT id, term FROM terms WHERE term_norm IS NULL').all();
  const up = db.prepare('UPDATE terms SET term_norm=? WHERE id=?');
  for (const r of rows) up.run(norm(r.term), r.id);
} catch (_) {}
try { db.prepare('CREATE UNIQUE INDEX IF NOT EXISTS idx_terms_user_norm ON terms(user_id, term_norm)').run(); } catch(_) {}

// âœ… è¿½åŠ ç”¨äºåˆ—è¡¨/æ¸…ç†çš„å¤åˆç´¢å¼•
try { db.prepare('CREATE INDEX IF NOT EXISTS idx_wf_slots_user_status ON wf_slots(user_id, status, updated_at DESC)').run(); } catch(_){}
try { db.prepare('CREATE INDEX IF NOT EXISTS idx_wf_slots_user_pinned ON wf_slots(user_id, pinned, updated_at DESC)').run(); } catch(_){}
 


// ---------- å°å·¥å…· ----------
function slotUpsert({ token, userId, termId=null, title='', textIn='' }) {
  const now = new Date().toISOString().slice(0,19).replace('T',' ');
  const existed = db.prepare('SELECT token FROM wf_slots WHERE token=?').get(token);
  if (existed) {
    db.prepare(`UPDATE wf_slots SET title=COALESCE(?,title), text_in=COALESCE(?,text_in),
               updated_at=? WHERE token=?`)
      .run(title||null, textIn||null, now, token);
  } else {
    db.prepare(`INSERT INTO wf_slots (token, user_id, term_id, title, text_in, status, created_at, updated_at)
                VALUES (?,?,?,?,?,?,?,?)`)
      .run(token, userId, termId, title, textIn, 'waiting', now, now);
  }
  // ğŸ”” é€šçŸ¥åŒè´¦å·å…¶å®ƒç«¯æ›´æ–°
  try { sseBroadcast(userId, 'slots_changed', { token: String(token) }); } catch (_) {}
}

function slotSetState(token, { status, textOut = null, errorMsg = null, incTry = false, progress = null }) {
  // âœ… ä¸€æ—¦åˆ°è¿‡ doneï¼Œå°±æ‹’ç»ä»»ä½•é done çš„çŠ¶æ€è¦†ç›–ï¼ˆç¡¬é”ï¼‰
  let cur = null;
  try {
    cur = slotGetByToken(token);
    if (cur && cur.status === 'done' && status !== 'done') {
      return; // å¿½ç•¥è¿™æ¬¡å†™å…¥
    }
  } catch (_) {}

  const now = new Date().toISOString().slice(0, 19).replace('T',' ');
  const triesSql = incTry ? 'tries = tries + 1,' : '';
  const progSql  = (typeof progress === 'number') ? 'progress = ?, ' : '';

  const args = [status];
  if (typeof progress === 'number') {
    args.push(Math.max(0, Math.min(100, Math.round(progress))));
  }
  args.push(textOut, errorMsg, now, token);

  db.prepare(`UPDATE wf_slots SET status=?, ${triesSql} ${progSql}
              text_out=COALESCE(?, text_out), error_msg=COALESCE(?, error_msg),
              updated_at=? WHERE token=?`).run(...args);

  // ğŸ”” é€šçŸ¥ï¼ˆé€šè¿‡ token åæŸ¥ user_idï¼‰
  try {
    const row = cur || slotGetByToken(token);
    if (row?.user_id) sseBroadcast(row.user_id, 'slots_changed', { token: String(token), status });
  } catch (_) {}
}


// ä»…æ›´æ–°å¿ƒè·³ï¼Œä¸æ”¹å˜çŠ¶æ€/è¿›åº¦
function slotTouchHB(token, { rttMs = null } = {}) {
  const now = new Date().toISOString().slice(0,19).replace('T',' ');
  if (typeof rttMs === 'number' && isFinite(rttMs)) {
    db.prepare(`
      UPDATE wf_slots
      SET hb_last_at=?, hb_rtt_ms=?, hb_count=COALESCE(hb_count,0)+1
      WHERE token=?
    `).run(now, Math.max(0, Math.round(rttMs)), token);
  } else {
    db.prepare(`
      UPDATE wf_slots
      SET hb_last_at=?, hb_count=COALESCE(hb_count,0)+1
      WHERE token=?
    `).run(now, token);
  }
}



function slotGetByToken(token){
  return db.prepare('SELECT * FROM wf_slots WHERE token=?').get(token);
}

function slotListByUser(userId){
  return db.prepare(`
    SELECT token, term_id, title, status, tries, progress, error_msg,
           hb_last_at, hb_rtt_ms, hb_count, pinned, opened_at,
           created_at, updated_at
    FROM wf_slots
    WHERE user_id=?
    ORDER BY pinned DESC, updated_at DESC          
    LIMIT 200
  `).all(userId);
}


function slotDelete(token, userId){
  db.prepare('DELETE FROM wf_slots WHERE token=? AND user_id=?').run(token, userId);
  // ğŸ”” é€šçŸ¥
  try { sseBroadcast(userId, 'slots_changed', { token: String(token), deleted: true }); } catch (_) {}
}

function logAction(userId, action, detailsObj = {}) {
  db.prepare('INSERT INTO logs (user_id, action, details) VALUES (?, ?, ?)').run(
    userId || null, action, JSON.stringify(detailsObj).slice(0, 4000)
  );
}
function enc(data) {
  const key = crypto.createHash('sha256').update(APP_KEY).digest(); // 32 bytes
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
  const enc = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);
  const tag = cipher.getAuthTag();
  return Buffer.concat([iv, tag, enc]).toString('base64');
}
function dec(b64) {
  const buf = Buffer.from(b64, 'base64');
  const iv = buf.subarray(0, 12);
  const tag = buf.subarray(12, 28);
  const enc = buf.subarray(28);
  const key = crypto.createHash('sha256').update(APP_KEY).digest();
  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(tag);
  const dec = Buffer.concat([decipher.update(enc), decipher.final()]).toString('utf8');
  return dec;
}
function assertAuth(req, res, next) {
  if (req.session && req.session.uid) return next();
  return res.status(401).json({ ok: false, error: 'UNAUTHORIZED' });
}
function genCSRF(req) {
  if (!req.session.csrf) req.session.csrf = crypto.randomBytes(16).toString('hex');
  return req.session.csrf;
}
function verifyCSRF(req, res, next) {
  const token = req.get('x-csrf-token');
  if (!token || token !== req.session.csrf) return res.status(403).json({ ok: false, error: 'BAD_CSRF' });
  next();
}
function normalizeSegment(seg){
  return (seg||'')
    .trim()
    .replace(/\s+/g,'-')
    .replace(/[^\w\-\u4e00-\u9fa5]/g,''); 
}
function pathify(input){
  if (!input || !String(input).trim()) return null;
  const raw = String(input).trim().replace(/\/+/g,'/');
  const parts = raw.split('/').filter((p,i)=> !(i===0 && p==='')); 
  const clean = [];
  for (const p of parts){
    if (p==='.' || p==='..') return null;
    const seg = normalizeSegment(p);
    if (!seg) return null;
    clean.push(seg);
  }
  return '/' + clean.join('/');
}
function normalizeTitle(s) {
  return (s || '').toLowerCase().replace(/\s+/g, '');
}

function splitTokens(s){
  return String(s||'').trim().split(/\s+/).filter(Boolean).map(x=>x.toLowerCase());
}
function tokenOverlap(main, cand){
  const A = new Set(splitTokens(main));
  const B = new Set(splitTokens(cand));
  if (!A.size || !B.size) return { matched:[], coverage:0, jaccard:0 };
  const matched = [...A].filter(t=>B.has(t));
  const coverage = matched.length / A.size;             // ç”¨äº UI çš„â€œç›¸ä¼¼åº¦â€
  const jaccard  = matched.length / new Set([...A,...B]).size; // å¤‡ç”¨
  return { matched, coverage, jaccard };
}

function isAbortErr(err){
  return err?.name === 'AbortError' || /aborted|AbortError/i.test(String(err?.message||err));
}

async function waitForPageByPath(gqlURL, token, pathSlug, tries=8, interval=800){
  for (let i=0;i<tries;i++){
    try{
      const data = await gqlRequest(gqlURL, token, `
        query($limit:Int!){
          pages { list(orderBy: TITLE, orderByDirection: ASC, limit:$limit){ id path title } }
        }`, { limit: 2000 });
      const hit = data?.data?.pages?.list?.find(p => (p.path||'') === pathSlug);
      if (hit) return hit;
    }catch{}
    await new Promise(r=>setTimeout(r, interval));
  }
  return null;
}


async function gqlRequest(url, token, query, variables = {}, timeoutMs = GQL_TIMEOUT_MS) {
  const ac = new AbortController();
  const timer = setTimeout(() => ac.abort(), timeoutMs);
  const t0 = Date.now();

  let res, raw, data;
  try {
    res = await fetch(url, {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
        'authorization': `Bearer ${token}`,
        'user-agent': 'wikiflow/1.0'
      },
      body: JSON.stringify({ query, variables }),
      signal: ac.signal
    });
    raw = await res.text();
    try { data = JSON.parse(raw); } catch {
      throw new Error(`GQL_HTTP_${res.status} (${Date.now()-t0}ms): ${raw.slice(0,200)}`);
    }
    if (!res.ok) {
      const msg = data?.errors?.map(e=>e.message).join(' | ') || raw.slice(0,200);
      throw new Error(`GQL_HTTP_${res.status} (${Date.now()-t0}ms): ${msg}`);
    }
    if (Array.isArray(data.errors) && data.errors.length) {
      const msg   = data.errors.map(e=>e.message).join(' | ');
      const where = data.errors.map(e=> (e.path||[]).join('.')).filter(Boolean).join(' , ');
      throw new Error(`GQL_ERR (${Date.now()-t0}ms): ${msg}${where?` @${where}`:''}`);
    }
    return data;
  } finally {
    clearTimeout(timer);
  }
}


async function fetchCandidates(gqlURL, token, title) {
  // â‘  ä¼˜å…ˆè¯• pages.searchï¼ˆæŸäº›ç‰ˆæœ¬æœ‰ï¼‰
  try {
    const q = `
      query($q:String!, $limit:Int!) {
        pages {
          search(query:$q, limit:$limit) {
            results { id path title score }
          }
        }
      }`;
    const data = await gqlRequest(gqlURL, token, q, { q: title, limit: 200 });
    const r = data?.data?.pages?.search?.results || [];
    if (r.length) return r.map(x => ({ id:x.id, path:x.path, title:x.title }));
  } catch (_) { /* ä¸æ”¯æŒå°±å¿½ç•¥ */ }

  // â‘¡ å…œåº•ï¼šlist åªç”¨ limitï¼ˆå¾ˆå¤š schema åªæ”¯æŒè¿™ä¸ªï¼‰
  const q2 = `
    query($limit:Int!) {
      pages {
        list(orderBy: TITLE, orderByDirection: ASC, limit: $limit) {
          id path title
        }
      }
    }`;
  const data2 = await gqlRequest(gqlURL, token, q2, { limit: 2000 }); // å¤Ÿå¤§å°±è¡Œ
  return data2?.data?.pages?.list || [];
}

async function wikiDeletePage(gqlURL, token, { id, path }) {
  // 1) å¦‚åªç»™äº† pathï¼Œå…ˆæŸ¥ ID
  if (!id && path) {
    const data = await gqlRequest(gqlURL, token, `
      query($limit:Int!){
        pages { list(orderBy: TITLE, orderByDirection: ASC, limit:$limit){ id path title } }
      }`, { limit: 2000 });
    const hit = data?.data?.pages?.list?.find(p => (p.path||'') === path);
    if (hit) id = hit.id;
  }
  if (!id) throw new Error('DEL_NO_ID');

  // 2) æ­£å¼åˆ é™¤ï¼šæ³¨æ„ id æ˜¯ Intï¼Œä¸æ˜¯ IDï¼›å­—æ®µåæ˜¯ deleteï¼Œä¸æ˜¯ remove
  const mutation = `
    mutation($id:Int!){
      pages {
        delete(id:$id){
          responseResult { succeeded errorCode message }
        }
      }
    }`;
  const resp = await gqlRequest(gqlURL, token, mutation, { id: Number(id) });
  const rr = resp?.data?.pages?.delete?.responseResult;
  if (!rr?.succeeded) {
    throw new Error(rr?.errorCode ? `${rr.errorCode} ${rr.message||''}` : 'DELETE_FAILED');
  }

  // 3) ï¼ˆå¯é€‰ï¼‰ç­‰ç´¢å¼•å›æ”¶ä¸€ä¸‹å†è¿”å›ï¼Œé¿å…ç´§è·Ÿç€åˆ›å»ºåŒ path è¿˜å‘½ä¸­æ—§ç¼“å­˜
  await new Promise(r => setTimeout(r, 400));
  return true;
}

// ---------- CLI: æ·»åŠ ç”¨æˆ· ----------
if (process.argv[2] === 'add-user') {
  (async () => {
    const username = process.argv[3];
    const password = process.argv[4];
    if (!username || !password) {
      console.log('ç”¨æ³•: npm run add-user -- <username> <password>');
      process.exit(1);
    }
    const hash = await bcrypt.hash(password, 12);
    db.prepare('INSERT INTO users (username, password_hash) VALUES (?, ?)').run(username, hash);
    console.log(`ç”¨æˆ·å·²åˆ›å»º: ${username}`);
    process.exit(0);
  })();
  return;
}


// ---------- App ----------
const jobs = new Map(); // id -> { userId, status, progress, message, url }

// ---------- WF Relay å­˜å‚¨ ----------
const wfStore = new Map(); // token -> { uid, textIn, textOut, state, ts }

function wfGc() {
  const now = Date.now();
  for (const [k, v] of wfStore) {
    // æœ€è¿‘æ´»è·ƒï¼šå¿ƒè·³ä¼˜å…ˆï¼Œå…¶æ¬¡ openedAtï¼Œå†å…¶æ¬¡æœ€åˆ put çš„ ts
    const lastActive = Math.max(
      Number(v.hb_last_at || 0),
      Number(v.openedAt  || 0),
      Number(v.ts        || 0),
    );

    const idleAged = lastActive && (now - lastActive > WF_IDLE_TTL_MS);
    const hardAged = (v.ts) && (now - v.ts > WF_MAX_TTL_MS);

    // ç»ˆæ€ç›´æ¥å›æ”¶ï¼›æœªç»ˆæ€æŒ‰â€œç©ºé—²TTL æˆ– ç»å¯¹TTLâ€å›æ”¶
    const terminal = v.state === 'done' || v.state === 'error';
    if (terminal || idleAged || hardAged) {
      wfStore.delete(k);
    }
  }
}
setInterval(wfGc, 60 * 1000); // æ¯åˆ†é’Ÿæ¸…ä¸€æ¬¡

// === è½®æ¬¡ç½®é¡¶ï¼ˆåç«¯è°ƒåº¦ï¼‰ ===
const rrCursor = new Map(); // userId -> ç´¢å¼•

if (WF_ROTATE) {
  setInterval(() => {
    try {
      // æ‰¾å‡ºæ‰€æœ‰æœ‰â€œå€™é€‰â€çš„ç”¨æˆ·
      const users = db.prepare(`
        SELECT DISTINCT user_id FROM wf_slots
        WHERE pinned=1 AND status IN ('picked','running')
      `).all().map(r => r.user_id);
      for (const uid of users) {
        // å€™é€‰é›†åˆï¼šè¯¥ç”¨æˆ· pinned=1 & è¿è¡Œä¸­çš„ tokenï¼ˆæŒ‰æ›´æ–°æ—¶é—´æ’åºæ›´è‡ªç„¶ï¼‰
        const rows = db.prepare(`
          SELECT token FROM wf_slots
          WHERE user_id=? AND pinned=1 AND status IN ('picked','running')
          ORDER BY updated_at DESC
        `).all(uid);
        if (!rows.length) continue;
        const idx = rrCursor.get(uid) ?? 0;
        const next = rows[idx % rows.length]?.token;
        rrCursor.set(uid, (idx + 1) % rows.length);
        // ä¸‹å‘ä¸€æ¬¡æ€§ focus æŒ‡ä»¤ï¼ˆä»…å½“å­é¡µåœ¨çº¿æ‰æœ‰æ„ä¹‰ï¼Œä¸ä¼šæ–°å¼€çª—ï¼‰
        const it = wfStore.get(String(next));
        if (it) it.poke = 'focus';
      }
    } catch (_) {}
  }, WF_ROTATE_INTERVAL_MS);
}

// ä»… /api/wf/* æ”¾å¼€çš„ CORSï¼ˆå­é¡µåœ¨ chatgpt.com ä¸Šè·¨åŸŸ fetch ç”¨ï¼‰
function wfCORS(req, res, next) {
  const origin = req.get('Origin');
  if (origin && WF_ALLOWED_ORIGINS.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Vary', 'Origin');
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'content-type');
    // helmet é»˜è®¤åŠ äº† CORP:same-originï¼Œè¿™é‡Œè¦†ç›–é¿å…æ‹¦æˆªè·¨åŸŸ fetch
    res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
  }
  if (req.method === 'OPTIONS') return res.status(204).end();
  next();
}

function newJobId(){ return crypto.randomBytes(8).toString('hex'); }
const app = express();
app.set('trust proxy', 1);
app.disable('x-powered-by');
app.use(helmet({ contentSecurityPolicy: false })); // ç®€åŒ– CSP ä»¥å…¼å®¹å†…åµŒè„šæœ¬
app.use(express.json({ limit: BODY_LIMIT }));
app.use(cookieSession({
  name: 'wf_sess',
  keys: [SESSION_SECRET],
  sameSite: 'strict',
  httpOnly: true,
  secure: (process.env.COOKIE_SECURE !== 'false' && NODE_ENV === 'production')
}));
const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 åˆ†é’Ÿçª—
  limit: 800000,          // æ¯åˆ†é’Ÿ 120 æ¬¡
  standardHeaders: true,
  legacyHeaders: false
});
app.use('/api/', apiLimiter);


// å…è®¸ chatgpt.com / chat.openai.com ä»å‰ç«¯å­é¡µæ‹‰å–ä¸å›ä¼ ï¼ˆä»… /api/wf/*ï¼‰
app.use('/api/wf', (req, res, next) => {
  const origin = req.headers.origin || '';
  const ok = /^(https:\/\/chatgpt\.com|https:\/\/chat\.openai\.com)$/.test(origin);
  if (ok) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Vary', 'Origin'); // è®© CDN/ç¼“å­˜æŒ‰ Origin åŒºåˆ†
  }
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'content-type');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

// ç›´æ¥æä¾›ç”¨æˆ·è„šæœ¬ï¼ˆä»å›ºå®šè·¯å¾„æ˜ å°„åˆ° /wf.user.jsï¼‰
app.get('/wf.user.js', (req, res) => {
  const scriptPath = process.env.WF_USER_SCRIPT_PATH || '/opt/wikiflow/public/wf.user.js';
  try {
    if (!fs.existsSync(scriptPath)) {
      return res.status(404).send('userscript not found: ' + scriptPath);
    }
    res.setHeader('Content-Type', 'text/javascript; charset=utf-8');
    return res.sendFile(scriptPath);
  } catch (e) {
    return res.status(500).send('failed to serve userscript: ' + (e?.message || e));
  }
});

// æ˜ å°„ /public é™æ€ç›®å½•ï¼ˆä¿®å¤ Cannot GET /public/wf.user.jsï¼‰
app.use('/public', express.static(path.join(__dirname, 'public'), {
  setHeaders(res, filePath) {
    if (filePath.endsWith('.user.js')) {
      res.setHeader('Content-Type', 'application/javascript; charset=utf-8');
      res.setHeader('Cache-Control', 'no-store');
    }
  }
}));


// é™æ€èµ„æº
app.use(express.static(path.join(__dirname, 'public'), { index: 'index.html', fallthrough: true }));

// å¥åº·æ£€æŸ¥
app.get('/healthz', (req,res)=>res.json({ok:true}));

// CSRF
app.get('/api/csrf', (req,res) => {
  res.json({ ok: true, token: genCSRF(req) });
});

// ä¼šè¯ä¿¡æ¯
app.get('/api/session', (req,res) => {
  const uid = req.session.uid;
  if (!uid) return res.json({ authenticated: false });

  const u  = db.prepare('SELECT username FROM users WHERE id=?').get(uid) || {};
  const st = db.prepare('SELECT wiki_base_url, wiki_graphql_url, wiki_token_cipher, locale, editor FROM user_settings WHERE user_id=?').get(uid) || {};

  res.json({
    authenticated: true,
    user: { id: uid, username: u.username || '' },
    settings: {
      wiki_base_url: st.wiki_base_url || DEFAULT_WIKI_BASE,
      wiki_graphql_url: st.wiki_graphql_url || DEFAULT_WIKI_GRAPHQL,
      locale: st.locale || DEFAULT_LOCALE,
      editor: st.editor || DEFAULT_EDITOR,
      has_token: !!st.wiki_token_cipher,                         // âœ… æ–°å¢
      token_preview: st.wiki_token_cipher ? ('â€¢â€¢â€¢â€¢' + (dec(st.wiki_token_cipher).slice(-4))) : '' // âœ… å¯é€‰é¢„è§ˆ
    }
  });
});

// ---------- SSE: per-user slots change stream ----------
const sseClients = new Map(); // userId -> Set(res)

function sseSend(res, event, data) {
  res.write(`event: ${event}\n`);
  res.write(`data: ${JSON.stringify(data)}\n\n`);
}

function sseBroadcast(uid, event, data = {}) {
  const set = sseClients.get(uid);
  if (!set || !set.size) return;
  for (const res of set) {
    try { sseSend(res, event, data); } catch (_) {}
  }
}

// äº‹ä»¶æºï¼šå‰ç«¯ç”¨ EventSource('/api/slots/stream') è®¢é˜…
app.get('/api/slots/stream', assertAuth, (req, res) => {
  const uid = req.session.uid;

  res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no'); // è‹¥ç”¨ Nginxï¼Œå…³é—­ç¼“å†²
  res.flushHeaders?.();

  let set = sseClients.get(uid);
  if (!set) { set = new Set(); sseClients.set(uid, set); }
  set.add(res);

  // åˆå§‹ pingï¼Œé¿å…æŸäº›ä»£ç†è¶…æ—¶
  sseSend(res, 'hello', { now: Date.now() });
  const iv = setInterval(() => sseSend(res, 'ping', { now: Date.now() }), 25000);

  req.on('close', () => {
    clearInterval(iv);
    const set = sseClients.get(uid);
    if (set) { set.delete(res); if (!set.size) sseClients.delete(uid); }
  });
});

// ç™»å½• / ç™»å‡º
app.post('/api/login', verifyCSRF, async (req,res) => {
  const { username, password } = req.body || {};
  if (!username || !password) return res.status(400).json({ ok:false, error: 'MISSING' });
  const u = db.prepare('SELECT * FROM users WHERE username=?').get(username);
  if (!u) return res.status(401).json({ ok:false, error:'INVALID' });
  const ok = await bcrypt.compare(password, u.password_hash);
  if (!ok) return res.status(401).json({ ok:false, error:'INVALID' });
  req.session.uid = u.id;
  genCSRF(req);
  db.prepare('INSERT INTO login_events (user_id, ip, ua) VALUES (?, ?, ?)').run(u.id, (req.headers['x-forwarded-for']||req.socket.remoteAddress||''), req.headers['user-agent']||'');
  logAction(u.id, 'login', { user: username });
  res.json({ ok: true });
});
app.post('/api/logout', verifyCSRF, assertAuth, (req,res) => {
  const uid = req.session.uid;
  req.session = null;
  logAction(uid, 'logout', {});
  res.json({ ok: true });
});

// ä¿å­˜è®¾ç½®ï¼ˆWiki.js ç«¯ç‚¹ä¸ tokenï¼‰
app.post('/api/settings', verifyCSRF, assertAuth, (req,res) => {
  const uid = req.session.uid;
  let { wiki_base_url, wiki_graphql_url, wiki_token, locale, editor } = req.body || {};
  if (!wiki_base_url && !wiki_graphql_url && !wiki_token && !locale && !editor) return res.status(400).json({ok:false,error:'EMPTY'});
  wiki_base_url = (wiki_base_url || DEFAULT_WIKI_BASE).trim();
  wiki_graphql_url = (wiki_graphql_url || DEFAULT_WIKI_GRAPHQL).trim();
  const encTok = wiki_token ? enc(wiki_token.trim()) : null;
  const row = db.prepare('SELECT user_id FROM user_settings WHERE user_id=?').get(uid);
  if (row) {
    const sql = `UPDATE user_settings SET wiki_base_url=COALESCE(?,wiki_base_url),
      wiki_graphql_url=COALESCE(?,wiki_graphql_url),
      wiki_token_cipher=COALESCE(?,wiki_token_cipher),
      locale=COALESCE(?,locale),
      editor=COALESCE(?,editor)
      WHERE user_id=?`;
    db.prepare(sql).run(wiki_base_url||null, wiki_graphql_url||null, encTok||null, locale||null, editor||null, uid);
  } else {
    db.prepare('INSERT INTO user_settings (user_id, wiki_base_url, wiki_graphql_url, wiki_token_cipher, locale, editor) VALUES (?,?,?,?,?,?)')
      .run(uid, wiki_base_url, wiki_graphql_url, encTok, locale||DEFAULT_LOCALE, editor||DEFAULT_EDITOR);
  }
  logAction(uid, 'save_settings', { wiki_base_url, wiki_graphql_url, has_token: !!wiki_token });
  res.json({ ok: true });
});

// é˜Ÿåˆ—ï¼šæ–°å¢ / åˆ—è¡¨ / åˆ é™¤
app.post('/api/terms', verifyCSRF, assertAuth, (req,res) => {
  const uid = req.session.uid;
  const { term } = req.body || {};
  if (!term || String(term).length > 200) return res.status(400).json({ok:false,error:'BAD_TERM'});


  const norm = String(term).toLowerCase().replace(/\s+/g,'').trim();
  try {
    const id = db.prepare('INSERT INTO terms (user_id, term, term_norm) VALUES (?,?,?)')
      .run(uid, String(term).trim(), norm).lastInsertRowid;
    logAction(uid, 'term_add', { id, term });
    return res.json({ ok: true, id });
  } catch (e) {
    if (/unique/i.test(String(e))) return res.status(409).json({ ok:false, error:'DUP_TERM' });
    return res.status(500).json({ ok:false, error:'TERM_ADD_FAIL' });
  }
});
app.get('/api/terms', assertAuth, (req,res) => {
  const uid = req.session.uid;
  const rows = db.prepare('SELECT id, term, status, created_at FROM terms WHERE user_id=? ORDER BY id DESC LIMIT 200').all(uid);
  res.json({ ok:true, items: rows });
});
app.delete('/api/terms/:id', verifyCSRF, assertAuth, (req,res)=>{
  const uid = req.session.uid;
  const id = Number(req.params.id);
  db.prepare('DELETE FROM terms WHERE id=? AND user_id=?').run(id, uid);
  logAction(uid, 'term_del', { id });
  res.json({ ok:true });
});

app.post('/api/wiki/check-duplicate', verifyCSRF, assertAuth, async (req, res) => {
  const uid = req.session.uid;
  const { title } = req.body || {};
  if (!title) return res.status(400).json({ ok: false, error: 'NO_TITLE' });

  const st = db.prepare('SELECT * FROM user_settings WHERE user_id=?').get(uid) || {};
  const gqlURL = st.wiki_graphql_url || DEFAULT_WIKI_GRAPHQL;
  const token = st.wiki_token_cipher ? dec(st.wiki_token_cipher) : null;
  if (!token) return res.status(400).json({ ok: false, error: 'NO_TOKEN' });

  // å½’ä¸€åŒ–ï¼šå°å†™ã€å»ç©ºæ ¼ã€å»æ‰éä¸­è‹±æ–‡ä¸æ•°å­—
  function norm(s) {
    return (s || '')
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[^\w\u4e00-\u9fa5]/g, '');
  }

  // æ ‡é¢˜æ•´ä½“å­—ç¬¦çº§ç›¸ä¼¼åº¦ï¼š
  //  - å¦‚æœä¸€æ–¹æ˜¯å¦ä¸€æ–¹çš„å­ä¸²ï¼Œç”¨ é•¿åº¦æ¯” ä½œä¸ºåˆ†æ•°ï¼ˆè¶Šæ¥è¿‘1è¶Šåƒï¼‰
  //  - å¦åˆ™ç”¨å­—ç¬¦é›†åˆäº¤å¹¶æ¯”ï¼ˆJaccardï¼‰
  function similarity(a, b) {
    const x = norm(a);
    const y = norm(b);
    if (!x || !y) return 0;

    if (x === y) return 1;

    if (x.includes(y) || y.includes(x)) {
      const maxLen = Math.max(x.length, y.length) || 1;
      const minLen = Math.min(x.length, y.length) || 0;
      return minLen / maxLen; // "æ•°å­¦æœŸæœ›" vs "æœŸæœ›" â‰ˆ 0.5
    }

    const sa = new Set(x.split(''));
    const sb = new Set(y.split(''));
    let inter = 0;
    for (const ch of sa) {
      if (sb.has(ch)) inter++;
    }
    const uni = new Set([...sa, ...sb]).size || 1;
    return inter / uni;
  }

  function longestTokenLen(arr) {
    return (arr || []).reduce((m, t) => Math.max(m, (t || '').length), 0);
  }

  const candidates = await fetchCandidates(gqlURL, token, title);
  const queryNorm = norm(title);

  const matches = (candidates || [])
    .map((p) => {
      const candTitle = String(p.title || '').trim();
      if (!candTitle) return null;

      const ov = tokenOverlap(title, candTitle) || { matched: [], coverage: 0 };
      const matchedTokens = ov.matched || [];
      const tokenCoverage = ov.coverage || 0;   // 0~1ï¼ŒåŸºäº token è¦†ç›–
      const titleSim = similarity(title, candTitle) || 0; // 0~1ï¼Œæ•´ä½“å­—ç¬¦ç›¸ä¼¼åº¦
      const maxTokenLen = longestTokenLen(matchedTokens);

      // å¦‚æœæ ‡é¢˜å½’ä¸€åŒ–åå®Œå…¨ä¸€è‡´ï¼Œç›´æ¥ç»™æ»¡åˆ†
      const candNorm = norm(candTitle);
      if (candNorm && candNorm === queryNorm) {
        return {
          id: p.id,
          path: p.path,
          title: candTitle,
          matchedTokens,
          similarity: 1,
          tokenCoverage: 1,
          titleSimilarity: 1,
          maxTokenLen,
        };
      }

      // ç»¼åˆåˆ†æ•°ï¼š
      //  - å– token è¦†ç›– & å­—ç¬¦ç›¸ä¼¼åº¦çš„â€œå¤§å€¼â€ä¸ºä¸»ï¼Œ
      //  - å°å€¼æŒ‰ 0.3 æƒé‡åŠ ä¸€ç‚¹ï¼Œé¿å…æŸä¸€ç»´å®Œå…¨å¤±çœŸã€‚
      const primary = Math.max(tokenCoverage, titleSim);
      const secondary = Math.min(tokenCoverage, titleSim);
      const combined = 0.7 * primary + 0.3 * secondary;

      return {
        id: p.id,
        path: p.path,
        title: candTitle,
        matchedTokens,
        similarity: combined,
        tokenCoverage,
        titleSimilarity: titleSim,
        maxTokenLen,
      };
    })
    .filter((m) => {
      if (!m) return false;

      // 1ï¼‰ç»¼åˆåˆ†æ•°å¤ªä½çš„ç›´æ¥è¿‡æ»¤ï¼ˆåŸºæœ¬ä¸ç›¸ä¼¼ï¼‰
      if (m.similarity < 0.3) return false;

      // 2ï¼‰å¦‚æœä¸€ä¸ª token éƒ½æ²¡å‘½ä¸­ï¼Œé‚£è‡³å°‘è¦â€œæ•´ä½“ç‰¹åˆ«åƒâ€æ‰ä¿ç•™
      if ((!m.matchedTokens || !m.matchedTokens.length) && m.titleSimilarity < 0.85) {
        return false;
      }

      // 3ï¼‰å‘½ä¸­è¯åªæœ‰ä¸€ä¸ªå­—æ¯/ä¸€ä¸ªæ±‰å­—ï¼Œè€Œä¸”æ•´ä½“ä¹Ÿä¸ç®—ç‰¹åˆ«åƒï¼Œå¤§æ¦‚ç‡æ˜¯å™ªå£°ï¼ˆ"çš„" / "a" ä¹‹ç±»ï¼‰
      if ((m.maxTokenLen || 0) <= 1 && m.titleSimilarity < 0.85) {
        return false;
      }

      return true;
    })
    .sort((a, b) => b.similarity - a.similarity);

  res.json({ ok: true, matches });
});

app.post('/api/wiki/delete', verifyCSRF, assertAuth, async (req, res) => {
  const uid = req.session.uid;
  const { id, path: pagePath } = req.body || {};

  const st      = db.prepare('SELECT * FROM user_settings WHERE user_id=?').get(uid) || {};
  const gqlURL  = st.wiki_graphql_url || DEFAULT_WIKI_GRAPHQL;
  const token   = st.wiki_token_cipher ? dec(st.wiki_token_cipher) : null;
  if (!token) return res.status(400).json({ ok:false, error:'NO_TOKEN' });
  if (!id && !pagePath) return res.status(400).json({ ok:false, error:'MISS_ID_OR_PATH' });

  try {
    await wikiDeletePage(gqlURL, token, { id, path: pagePath });
    logAction(uid, 'wiki_delete_ok', { id, path: pagePath });
    res.json({ ok:true });
  } catch (e) {
    logAction(uid, 'wiki_delete_fail', { id, path: pagePath, err: String(e?.message||e) });
    res.status(500).json({ ok:false, error:'DELETE_FAIL', message: String(e?.message||e) });
  }
});


// Wiki.jsï¼šåˆ›å»ºæˆ–è¦†ç›–é¡µé¢
// ----------------------------------------------------
// å‰ç«¯ç›´æ¥è°ƒç”¨è¿™ä¸ªæ¥å£ â†’ ç«‹å³å°è¯•æäº¤åˆ° Wiki.js
// ä¸ /api/jobs/submit ä¸åŒï¼Œè¿™é‡Œä¸ä¼šè¿›å…¥é˜Ÿåˆ—ï¼Œè€Œæ˜¯ç›´æ¥æ‰§è¡Œã€‚
// ----------------------------------------------------
app.post('/api/wiki/submit', verifyCSRF, assertAuth, async (req,res) => {
  const uid = req.session.uid;
  const { mode, existingId, title, tags, content } = req.body || {};
  const desc = String((req.body?.desc ?? req.body?.description ?? '') || '').slice(0,500);

  // åŸºç¡€æ ¡éªŒï¼šå¿…é¡»æœ‰æ ‡é¢˜å’Œå†…å®¹
  if (!title || !content) {
    return res.status(400).json({ ok:false, error:'MISS_FIELDS' });
  }

  // å–å‡ºç”¨æˆ·é…ç½®ï¼ˆGraphQL åœ°å€ã€Tokenã€è¯­è¨€ã€ç¼–è¾‘å™¨ç­‰ï¼‰
  const st = db.prepare('SELECT * FROM user_settings WHERE user_id=?').get(uid) || {};
  const gqlURL  = st.wiki_graphql_url || DEFAULT_WIKI_GRAPHQL;
  const baseURL = st.wiki_base_url    || DEFAULT_WIKI_BASE;
  const token   = st.wiki_token_cipher ? dec(st.wiki_token_cipher) : null;
  const locale  = st.locale || DEFAULT_LOCALE;
  const editor  = st.editor || DEFAULT_EDITOR;

  if (!token) {
    return res.status(400).json({ ok:false, error:'NO_TOKEN' });
  }

  // æŠŠæ ‡é¢˜è§„æ•´æˆåˆæ³• path
  let pathSlug = pathify(title);
  if (!pathSlug) {
    return res.status(400).json({ ok:false, error:'BAD_TITLE' });
  }

  try {
    let resp;

    // -------------------------------
    // 1. å¦‚æœæ˜¯è¦†ç›–æ¨¡å¼ (overwrite)
    // -------------------------------
    if (mode === 'overwrite' && existingId) {
      const mutation = `
      mutation ($id:Int!, $title:String!, $path:String!, $content:String!, $tags:[String]!, $locale:String!, $editor:String!, $description:String!) {
        pages {
          update(
            id:$id, title:$title, path:$path, content:$content, tags:$tags,
            locale:$locale, isPublished:true, isPrivate:false, editor:$editor
            , description:$description
          ) {
            responseResult { succeeded errorCode slug message }
            page { id path title }
          }
        }
      }`;

      // è°ƒç”¨ gqlRequestï¼ˆè¿™é‡Œå¦‚æœå¤±è´¥ä¼šæŠ›å‡ºå¸¦è¯¦ç»†ä¿¡æ¯çš„ Errorï¼‰
      const normTags = Array.isArray(tags) ? tags.filter(t => t != null).map(String) : [];
      resp = await gqlRequest(gqlURL, token, mutation, {
        id: Number(existingId),
        title,
        path: pathSlug,
        content,
        tags: normTags,
        description: desc,
        locale,
        editor
      });
    } else {
      // -------------------------------
      // 2. åˆ›å»ºæ–°é¡µé¢
      // -------------------------------
      const mutation = `
      mutation ($title:String!, $path:String!, $content:String!, $tags:[String]!, $locale:String!, $editor:String!, $description:String!) {
        pages {
          create(
            title:$title, path:$path, description:$description, content:$content, tags:$tags,
            locale:$locale, isPublished:true, isPrivate:false, editor:$editor
          )  {
            responseResult { succeeded errorCode slug message }
            page { id path title }
          }
        }
      }`;


      const normTags = Array.isArray(tags) ? tags.filter(t => t != null).map(String) : [];
      resp = await gqlRequest(gqlURL, token, mutation, {
        title,
        path: pathSlug,
        content,
        tags: normTags,
        locale,
        editor,
        description: desc
      });
    }

    // -------------------------------
    // 3. æ£€æŸ¥ GraphQL è¿”å›ç»“æœ
    // -------------------------------
    const rr   = resp.data?.pages?.create?.responseResult || resp.data?.pages?.update?.responseResult;
    const page = resp.data?.pages?.create?.page || resp.data?.pages?.update?.page;

    if (!rr?.succeeded) {
      // GraphQL æ­£å¸¸è¿”å›ï¼Œä½†ä¸šåŠ¡å¤±è´¥ï¼ˆå¦‚è·¯å¾„å†²çªï¼‰
      return res.status(409).json({
        ok: false,
        error: 'WIKI_FAIL',
        code: rr?.errorCode,
        slug: rr?.slug,
        message: rr?.message
      });
    }

    // -------------------------------
    // 4. æˆåŠŸ â†’ å†™å…¥æ•°æ®åº“æ—¥å¿—
    // -------------------------------
    db.prepare(`
      INSERT INTO terms (user_id, term, status, title, tags_json, content, wiki_page_id, wiki_path)
      VALUES (?,?,?,?,?,?,?,?)
    `).run(
      uid,
      title,
      'posted',
      title,
      JSON.stringify(tags||[]),
      content.slice(0, 200000), // å†…å®¹å¤ªé•¿æ—¶æˆªæ–­å­˜å‚¨
      page.id,
      page.path
    );

    // æ‹¼æ¥é¡µé¢ URL
    const url = baseURL.replace(/\/+$/,'') + (page.path.startsWith('/') ? page.path : '/' + page.path);

    // è®°å½•æ“ä½œæ—¥å¿—
    logAction(uid, 'wiki_submit_ok', { title, url, mode: mode||'create' });

    // è¿”å›ç»™å‰ç«¯
    res.json({ ok:true, url, page });

  } catch (err) {
    // -------------------------------
    // 5. æ•æ‰å¼‚å¸¸ï¼ˆGraphQL æŠ¥é”™/ç½‘ç»œé”™è¯¯ï¼‰
    // -------------------------------
    logAction(uid, 'wiki_submit_fail', { title, err: String(err?.message||err) });

    return res.status(500).json({
      ok: false,
      error: 'WIKI_SUBMIT_FAIL',
      message: String(err?.message||err)   // è¿™é‡Œä¼šæŠŠ gqlRequest çš„é”™è¯¯é€ä¼ å›å‰ç«¯
    });
  }
});

// æäº¤ä»»åŠ¡ï¼šåˆ›å»º/è¦†ç›–é¡µé¢ï¼ˆå¹¶å¯æ¸…ç†é˜Ÿåˆ—é¡¹ï¼‰
app.post('/api/jobs/submit', verifyCSRF, assertAuth, async (req,res)=>{
  const uid = req.session.uid;
  const { termId, mode, existingId, title, tags, content, cleanup, force, deleteFirst } = req.body || {};
  const desc = String((req.body?.desc ?? req.body?.description ?? '') || '').slice(0,500);
  if (!title || !content) return res.status(400).json({ ok:false, error:'MISS_FIELDS' });

  const id = newJobId();
  jobs.set(id, { userId: uid, title, status:'queued', progress:0, message:'æ’é˜Ÿä¸­â€¦' });
  res.json({ ok:true, id });

  // çœŸæ­£æ‰§è¡Œ
  (async ()=>{
    const job = jobs.get(id); if(!job) return;
    try{
      job.status='running'; job.progress=10; job.message='å‡†å¤‡å‚æ•°â€¦';

      const st = db.prepare('SELECT * FROM user_settings WHERE user_id=?').get(uid) || {};
      const gqlURL = st.wiki_graphql_url || DEFAULT_WIKI_GRAPHQL;
      const baseURL = st.wiki_base_url || DEFAULT_WIKI_BASE;
      const token = st.wiki_token_cipher ? dec(st.wiki_token_cipher) : null;
      const locale = st.locale || DEFAULT_LOCALE;
      const editor = st.editor || DEFAULT_EDITOR;
      if (!token) throw new Error('NO_TOKEN');

      const pathSlug = pathify(title);
      if (!pathSlug) throw new Error('BAD_TITLE');

      // â‘  åˆ¤é‡ï¼ˆä¿æŒåŸé€»è¾‘ï¼‰
      job.progress = 20; job.message = 'æ£€æŸ¥å¯èƒ½é‡å¤/ç›¸ä¼¼â€¦';
      const candidates = await fetchCandidates(gqlURL, token, title);
      const dupList = (candidates||[])
        .map(p => {
          const ov = tokenOverlap(title, p.title||'');
          return { id:p.id, path:p.path, title:p.title, matchedTokens: ov.matched, similarity: ov.coverage };
        })
        .filter(m => m.matchedTokens.length > 0)
        .sort((a,b) => b.similarity - a.similarity);

      if (dupList.length){
        job.dups = dupList;
        if (!force) {
          job.status='error'; job.progress=0;
          job.message='æ£€æµ‹åˆ°å¯èƒ½é‡å¤/ç›¸ä¼¼é¡µé¢ï¼ˆå¯æ”¹æ ‡é¢˜ï¼›æˆ–ç‚¹â€œåšæŒæäº¤â€ç»§ç»­ï¼‰';
          return;
        } else {
          logAction(uid, 'duplicate_override', { title, top: dupList[0] });
          job.message='æ£€æµ‹åˆ°å¯èƒ½é‡å¤ï¼Œå·²æŒ‰â€œåšæŒæäº¤â€ç»§ç»­â€¦';
        }
      }

      // â‘¡ æäº¤åˆ° Wiki.js
      job.progress=35; job.message='æäº¤åˆ° Wiki.jsâ€¦';
      let resp;
      const normTags = Array.isArray(tags) ? tags.filter(t => t != null).map(String) : [];

      if (mode === 'overwrite' && existingId) {
        if (deleteFirst) {
          // â€”â€” å…ˆåˆ å†å»º â€”â€”
          job.message = 'è¦†ç›–ï¼šå…ˆåˆ é™¤æ—§é¡µé¢â€¦';
          await wikiDeletePage(gqlURL, token, { id: Number(existingId) });
          await new Promise(r=>setTimeout(r, 400));

          job.message = 'è¦†ç›–ï¼šåˆ›å»ºæ–°é¡µé¢â€¦';
          const mCreate = `
            mutation ($title:String!, $path:String!, $content:String!, $tags:[String]!,
                      $locale:String!, $editor:String!, $description:String!) {
              pages {
                create(
                  title:$title, path:$path, description:$description, content:$content, tags:$tags,
                  locale:$locale, isPublished:true, isPrivate:false, editor:$editor
                ) {
                  responseResult { succeeded errorCode slug message }
                  page { id path title }
                }
              }
            }`;
          resp = await gqlRequest(gqlURL, token, mCreate, {
            title, path: pathSlug, content, tags: normTags,
            locale, editor, description: desc
          });
        } else {
          // â€”â€” ç›´æ¥æ›´æ–° â€”â€”
          const mUpdate = `
            mutation ($id:Int!, $title:String!, $path:String!, $content:String!, $tags:[String]!,
                      $locale:String!, $editor:String!) {
              pages {
                update(
                  id:$id, title:$title, path:$path, content:$content, tags:$tags,
                  locale:$locale, isPublished:true, isPrivate:false, editor:$editor
                ) {
                  responseResult { succeeded errorCode slug message }
                  page { id path title }
                }
              }
            }`;
          resp = await gqlRequest(gqlURL, token, mUpdate, {
            id: Number(existingId), title, path: pathSlug, content,
            tags: normTags, locale, editor
          });
        }
      } else {
        // â€”â€” æ–°å»º â€”â€”
        const mCreate = `
          mutation ($title:String!, $path:String!, $content:String!, $tags:[String]!,
                    $locale:String!, $editor:String!, $description:String!) {
            pages {
              create(
                title:$title, path:$path, description:$description, content:$content, tags:$tags,
                locale:$locale, isPublished:true, isPrivate:false, editor:$editor
              ) {
                responseResult { succeeded errorCode slug message }
                page { id path title }
              }
            }
          }`;
        resp = await gqlRequest(gqlURL, token, mCreate, {
          title, path: pathSlug, content, tags: normTags,
          locale, editor, description: desc
        });
      }

      // â‘¢ æ£€æŸ¥ç»“æœ
      const rr = resp.data?.pages?.create?.responseResult || resp.data?.pages?.update?.responseResult;
      const page = resp.data?.pages?.create?.page || resp.data?.pages?.update?.page;
      if (!rr?.succeeded) {
        throw new Error(`WIKI_FAIL ${rr?.errorCode||''} ${rr?.message||''}`.trim());
      }

      // â‘£ å†™åº“
      if (cleanup && termId) {
        db.prepare('DELETE FROM terms WHERE id=? AND user_id=?').run(Number(termId), uid);
      } 
      // else {
      //   db.prepare(`INSERT INTO terms (user_id, term, status, title, tags_json, content, wiki_page_id, wiki_path)
      //               VALUES (?,?,?,?,?,?,?,?)`)
      //     .run(uid, title, 'posted', title, JSON.stringify(tags||[]),
      //          content.slice(0,200000), page.id, page.path);
      // }

      const url = baseURL.replace(/\/+$/,'') + (page.path.startsWith('/') ? page.path : '/' + page.path);
      logAction(uid, 'wiki_submit_ok', { title, url, mode: mode||'create' });

      job.progress=100; job.status='done'; job.url=url; job.message='å®Œæˆ';
    }catch(err){
      logAction(uid, 'wiki_submit_fail', { title, err: String(err?.message||err) });
      const job = jobs.get(id); if (!job) return;
      job.status='error'; job.progress=0; job.message = String(err?.message||err);
    }
  })();
});


// ä»»åŠ¡æŸ¥è¯¢
app.get('/api/jobs/:id', assertAuth, (req,res)=>{
  const job = jobs.get(req.params.id);
  if (!job || job.userId !== req.session.uid) return res.status(404).json({ ok:false, error:'NOT_FOUND' });
  res.json({
    ok:true,
    id: req.params.id,
    title: job.title,
    status: job.status,
    progress: job.progress,
    message: job.message,
    url: job.url,
    dups: job.dups   // â­ æ–°å¢
  });

});

// åˆ—å‡ºå½“å‰ç”¨æˆ·çš„æ‰€æœ‰ä»»åŠ¡ï¼ˆä»…å†…å­˜é˜Ÿåˆ—ï¼Œé‡å¯åä¸å¯æ¢å¤ï¼‰
app.get('/api/jobs', assertAuth, (req,res)=>{
  const uid = req.session.uid;
  const items = [];
  for (const [id, j] of jobs.entries()) {
    if (j.userId === uid) {
      items.push({ id, title: j.title, status: j.status, progress: j.progress, message: j.message, url: j.url });
    }
  }
  // è®©æœªå®Œæˆçš„ä»»åŠ¡æ’åœ¨å‰é¢
  items.sort((a,b)=>{
    const ra = (a.status==='done'||a.status==='error') ? 1 : 0;
    const rb = (b.status==='done'||b.status==='error') ? 1 : 0;
    return ra - rb || (b.progress - a.progress);
  });
  res.json({ ok:true, items });
});

app.post('/api/jobs/clear', verifyCSRF, assertAuth, (req,res)=>{
  const uid = req.session.uid;
  const { scope } = req.body || {};
  for (const [id, j] of [...jobs.entries()]) {
    if (j.userId !== uid) continue;
    if (scope === 'all' || (scope==='done' && (j.status==='done' || j.status==='error'))){
      jobs.delete(id);
    }
  }
  res.json({ ok:true });
});

// ---------- WF Relay API ----------

// çˆ¶é¡µï¼šæäº¤ payloadï¼ˆéœ€è¦ç™»å½• + CSRFï¼‰
app.post('/api/wf/put', verifyCSRF, assertAuth, (req, res) => {
  const uid = req.session.uid;
  const { token, text } = req.body || {};
  if (!token || typeof text !== 'string') return res.status(400).json({ ok:false, error:'BAD_REQUEST' });

  console.log('[wf.put]', { uid, token, chars: text.length, bytes: Buffer.byteLength(text, 'utf8') }); // â­ è°ƒè¯•

  wfStore.set(String(token), {
    uid, textIn: String(text), textOut: '', state: 'waiting', ts: Date.now(), openedAt: null  
  });
  // æŠŠä»»åŠ¡ä¹Ÿå†™å…¥ slotsï¼Œæ˜¾ç¤ºåœ¨â€œç”Ÿæˆé˜Ÿåˆ—â€
  try {
    slotUpsert({
      token: String(token),
      userId: uid,
      termId: req.body?.termId || null,
      title: req.body?.title || '',
      textIn: String(text)
    });
    slotSetState(String(token), { status: 'waiting' });
    // âœ… æ–°æ”¾å…¥çš„ä»»åŠ¡è‡ªåŠ¨ç½®é¡¶&ç‹¬å ï¼ˆæé«˜â€œä¸‹ä¸€è½®â€çš„å‰å°èšç„¦ä¼˜å…ˆçº§ï¼‰
    db.prepare('UPDATE wf_slots SET pinned=0 WHERE user_id=?').run(uid);
    db.prepare('UPDATE wf_slots SET pinned=1, updated_at=CURRENT_TIMESTAMP WHERE token=? AND user_id=?')
      .run(String(token), uid);
  } catch (e) {
    console.warn('[wf.put] slot upsert failed:', e);
  }

  wfGc();
  res.json({ ok:true });
  try { sseBroadcast(uid, 'slots_changed', { token: String(token) }); } catch (_) {}
});

// å­é¡µï¼šé¢†å– payloadï¼ˆè·¨åŸŸï¼›ä¸è¦æ±‚ç™»å½•/CSRFï¼‰
// å­é¡µï¼šé¢†å– payloadï¼ˆè·¨åŸŸï¼›ä¸è¦æ±‚ç™»å½•/CSRFï¼‰
app.get('/api/wf/get', wfCORS, (req, res) => {
  const token = String(req.query.token || '');
  let it = wfStore.get(token);

  // â‘  å†…å­˜æœªå‘½ä¸­ â†’ å°è¯•ä» SQLite â€œå¤æ´»â€
  if (!it) {
    try {
      const row = slotGetByToken(token);
      if (row) {
        const terminal = (row.status === 'done' || row.status === 'error');
        if (terminal) {
          return res.status(410).json({ ok:false, error:'ALREADY_FINISHED' });
        }
        if (row.text_in && row.user_id) {
          // å¤æ´»å†…å­˜é•œåƒ
          it = {
            uid: row.user_id,
            textIn: String(row.text_in || ''),
            textOut: String(row.text_out || ''),
            state: row.status || 'waiting',
            ts: Date.now(),
            openedAt: null
          };
          wfStore.set(token, it);
        }
      }
    } catch (_) {}
  }

  // â‘¡ è¿˜æ˜¯æ²¡æœ‰ï¼šä¿æŒ 404ï¼ˆä½†å·²å°½åŠ›å¤æ´»ï¼‰
  if (!it) {
    return res.status(404).json({ ok:false, error:'NO_TASK' });
  }

  // â‘¢ æ­£å¸¸é¢†å–
  it.state = 'picked';
  it.ts = Date.now();
  if (!it.openedAt) it.openedAt = Date.now();
  try { slotSetState(token, { status: 'picked' }); } catch {}
  try {
    db.prepare(`
      UPDATE wf_slots
      SET opened_at = COALESCE(opened_at, CURRENT_TIMESTAMP), updated_at=CURRENT_TIMESTAMP
      WHERE token=?`).run(token);
  } catch(_) {}
  res.json({ ok:true, text: it.textIn || '' });
});


// å­é¡µï¼šå›ä¼ ç»“æœæˆ–ä¿¡å·ï¼ˆè·¨åŸŸï¼›ä¸è¦æ±‚ç™»å½•/CSRFï¼‰
app.post('/api/wf/done', wfCORS, express.json({ limit: BODY_LIMIT }), (req, res) => {
  const { token, text, state } = req.body || {};
  const lowText = String(text || '').toLowerCase();
  const isHB = ((state === 'picked' || state === 'running') && lowText === 'hb');
  const t = String(token || '');

  const hbMode = String(req.body?.hb_mode || '').toLowerCase(); // 'tick' | 'beacon' | ''
  const sid    = String(req.body?.sid || '');
  const seq    = Number(req.body?.seq || 0);

  // 1) å†…å­˜ä»»åŠ¡å¿…é¡»å­˜åœ¨ï¼ˆç”¨äºé‰´åˆ«ä¸é™æ—¶ï¼‰
  let it = wfStore.get(t);
  if (!it && isHB) {
    // ï¼ˆå¯é€‰ï¼‰ä»…å¯¹ tick è®°å¿ƒè·³ï¼Œbeacon ä¸åˆ·æ–° idle
    let rttMs = null;
    const clientTs = Number(req.body?.client_ts ?? req.body?.sent_at ?? req.body?.t);
    if (Number.isFinite(clientTs)) {
      const now = Date.now();
      const diff = now - clientTs;
      if (diff >= 0 && diff < 120000) rttMs = diff;
    }
    if (hbMode === 'tick') {
      try { slotTouchHB(t, { rttMs }); } catch (_) {}
    }
    let row = null; try { row = slotGetByToken(t); } catch (_){}
    const terminal = !!row && (row.status === 'done' || row.status === 'error');
    return res.json({ ok:true, status: row?.status || 'running', hb:true, final: terminal, closeRequested: terminal });
  }

  // â˜…â˜…â˜… æ’å…¥åœ¨è¿™é‡Œï¼šè¿›å…¥å¿ƒè·³åˆ†æ”¯ä¹‹å‰ï¼Œå…ˆåš sid/seq å»é‡ä¸ä¹±åºä¸¢å¼ƒ
  if (isHB && hbMode === 'tick' && it) {
    if (sid) {
      if (!it.sid) it.sid = sid;                    // ç»‘å®šæœ¬æ¬¡ä¼šè¯çš„çª—å£ID
      // ä¸åŒçª—å£ æˆ– åºå·ä¸é€’å¢ â†’ å¿½ç•¥è¿™æ¬¡å¿ƒè·³ï¼ˆä¸åˆ·æ–° hb / idleï¼‰
      if (it.sid !== sid || (it.lastSeq && seq <= it.lastSeq)) {
        const row = (()=>{ try { return slotGetByToken(t);} catch(_){ return null; }})();
        const terminal = !!row && (row.status === 'done' || row.status === 'error');
        return res.json({ ok:true, status: row?.status || it.state || 'running', hb:true, final: terminal, closeRequested: terminal });
      }
      it.lastSeq = seq; // æ­£å¸¸é€’å¢ï¼Œæ”¾è¡Œ
    }
  }

  // == å¿ƒè·³ï¼šstate=running && text==='hb' â†’ åªæ›´æ–° hbï¼Œä¸åŠ¨çŠ¶æ€ ==
  if (isHB) {
    // ä»…å¯¹ tick è®° hbï¼›beacon åªå›çŠ¶æ€ä¸åˆ·æ–° idle
    let rttMs = null;
    const clientTs = Number(req.body?.client_ts ?? req.body?.sent_at ?? req.body?.t);
    if (Number.isFinite(clientTs)) {
      const now = Date.now();
      const diff = now - clientTs;
      if (diff >= 0 && diff < 120000) rttMs = diff;
    }

    if (hbMode === 'tick') {
      try { slotTouchHB(t, { rttMs }); } catch (e) { console.warn('[wf.done][hb] slotTouchHB failed:', e); }
      try { it.ts = Date.now(); } catch (_) {}
    }

    let currentStatus = it?.state || 'running';
    let terminal = false;
    try {
      const row = slotGetByToken(t);
      if (row?.status) {
        currentStatus = row.status;
        terminal = (row.status === 'done' || row.status === 'error');
      }
    } catch {}

    const flags = {};
    if (it?.kill) flags.closeRequested = true;
    if (it?.poke === 'focus') {
      try {
        const row2 = slotGetByToken(t);
        if (!terminal && row2?.pinned) {
          const now = Date.now();
          const thr = WF_PIN_FOCUS_THROTTLE_MS;
          if (!it._lastFocusAt || (now - it._lastFocusAt) >= thr) {
            flags.focusRequested = true;
            it._lastFocusAt = now;
          }
        }
      } catch {}
    }
    if (terminal) flags.closeRequested = true;

    if (hbMode === 'tick') {
      it.hb_last_at = Date.now();
      if (rttMs != null) it.hb_rtt_ms = rttMs;
    }

    return res.json({ ok:true, status: currentStatus, hb: true, final: terminal, ...flags });
  }

  // == å¿ƒè·³åˆ†æ”¯ç»“æŸï¼Œåé¢æ˜¯åŸæ¥çš„çŠ¶æ€å¤„ç† ==

  // â€”â€” æ‰“å¼€ç¬é—´æ ‡è®° â€”â€”
  // state=running ä¸” text = 'child-opened' è§†ä¸ºâ€œçª—å£å·²æ‰“å¼€â€
  if ((state === 'picked' || state === 'running') && String(text || '').toLowerCase() === 'child-opened') {
    try { 
      db.prepare(`
        UPDATE wf_slots 
        SET opened_at = COALESCE(opened_at, CURRENT_TIMESTAMP), updated_at=CURRENT_TIMESTAMP 
        WHERE token=?`).run(t);
    } catch(_) {}
  }

  // 2) ä»…å…è®¸è¿™äº”ç§çŠ¶æ€
  const allowed = new Set(['picked','running','retrying','done','error']);
  if (!allowed.has(state)) {
    return res.status(400).json({ ok:false, error:'BAD_STATE' });
  }

  // 3) è¯»å–å½“å‰ slotï¼Œç»ˆæ€ä¸å¯å›é€€
  let row = null;
  try { row = slotGetByToken(t); } catch {}
  const terminal = new Set(['done','error']);
  if (row && terminal.has(row.status) && !terminal.has(state)) {
    // å·²ç» done/error äº†ï¼Œå°±å¿½ç•¥åç»­ running/retrying
    it.ts = Date.now();
    return res.json({ ok:true, ignored:true, status: row.status });
  }

  // âœ… å¹‚ç­‰ä¿æŠ¤ â€”â€” å¦‚æœå·²ç» doneï¼Œå°±æ‹’ç»è¢« error è¦†ç›–
  if (row && row.status === 'done') {
    if (state === 'error') {
      console.warn('[wf.done] ignore error-after-done', t);
      it.ts = Date.now();
      return res.json({ ok:true, ignored:'error-after-done', status:'done' });
    }
    if (state === 'done') {
      // å¦‚æœé‡å¤ doneï¼Œåªæœ‰å½“æ–°å†…å®¹æ›´é•¿æ—¶æ‰è¦†ç›–
      if (typeof text === 'string' && text.length > (row.text_out?.length || 0)) {
        try { slotSetState(t, { status:'done', textOut: text }); } catch(e){}
        it.textOut = text;
      }
      it.state = 'done';
      it.ts = Date.now();
      return res.json({ ok:true, idempotent:true, status:'done' });
    }
  }

  // 4) ä»…åœ¨ done / error æ—¶å†™æ­£æ–‡ï¼Œrunning/retrying ä¸è¦†ç›– text_out
  const p = Number.isFinite(req.body?.progress)
    ? Math.max(0, Math.min(100, Math.round(Number(req.body.progress))))
    : null;

  const reason = (typeof text === 'string' ? text : '');
  let errorMsg = null; // null è¡¨ç¤ºä¸æ”¹åŠ¨æ—§å€¼
  
  // retrying / error æ—¶è®°å½•åŸå› ï¼Œdone æ—¶æ¸…ç©ºï¼Œå…¶ä»–çŠ¶æ€ä¿æŒåŸæ ·
  if (state === 'retrying' || state === 'error') {
    errorMsg = reason.slice(0, 1000);
  } else if (state === 'done') {
    errorMsg = ''; // æˆåŠŸåæ¸…ç©ºæ—§çš„é”™è¯¯æˆ–é‡è¯•åŸå› 
  }
  
  const update = {
    status: state,
    textOut: (state === 'done' || state === 'error') ? reason : null,
    errorMsg,
    incTry: (state === 'retrying'),
    progress: (state === 'done') ? 100 : p
  };



  try { slotSetState(t, update); } catch (e) {
    console.warn('[wf.done] slot set state failed:', e);
  }

  // 5) æ›´æ–°å†…å­˜é•œåƒ
  if (state === 'done' || state === 'error') it.textOut = String(text || '');
  it.state = state;
  it.ts = Date.now();

  console.log('[wf.done]', { token: t, state, outChars: (text||'').length });
  const isTerminal = (state === 'done' || state === 'error');
  if (isTerminal) it.kill = true; // æ”¶å°¾ï¼šè®©å­é¡µå°½å¿«å…³é—­ï¼Œåœæ­¢è®¡æ—¶
  res.json({ ok:true, status: state, final: isTerminal, closeRequested: isTerminal });
});


// çˆ¶é¡µï¼šå¯¹æ­£åœ¨ç”Ÿæˆçš„å­é¡µä¸‹å‘ä¸€æ¬¡æ€§æŒ‡ä»¤ï¼ˆéœ€è¦ç™»å½• + CSRFï¼‰
app.post('/api/wf/poke', verifyCSRF, assertAuth, (req, res) => {
  const uid = req.session.uid;
  const { token, action } = req.body || {};
  const t = String(token || '');
  if (!t) return res.status(400).json({ ok:false, error:'BAD_REQUEST' });

  const it = wfStore.get(t);
  if (!it) return res.status(404).json({ ok:false, error:'NO_TASK' });
  if (it.uid !== uid) return res.status(403).json({ ok:false, error:'FORBIDDEN' });

  if (action === 'focus') {
    it.poke = 'focus';                 // ä¸‹ä¸€æ¬¡ HB è¿”å› focusRequested=true
  } else if (action === 'close') {
    it.kill = true;
    try {
      const row = slotGetByToken(t);
      if (!row || (row.status !== 'done' && row.status !== 'error')) {
        slotSetState(t, { status:'error', errorMsg:'closed-by-user' });
      }
    } catch {}
  } else {
    return res.status(400).json({ ok:false, error:'BAD_ACTION' });
  }
  it.ts = Date.now();
  return res.json({ ok:true });
});


// çˆ¶é¡µï¼šæŸ¥çŠ¶æ€ï¼ˆéœ€è¦ç™»å½•ï¼›åªèƒ½æŸ¥è‡ªå·± tokenï¼‰
app.get('/api/wf/state', assertAuth, (req, res) => {
  const uid = req.session.uid;
  const token = String(req.query.token || '');
  const it = wfStore.get(token);

  if (!it) return res.json({ ok:true, state: 'waiting' }); // æ²¡æœ‰å°±å½“ waitingï¼Œé¿å…æ³„éœ² token
  if (it.uid !== uid) return res.status(403).json({ ok:false, error:'FORBIDDEN' });

  res.json({ ok:true, state: it.state || 'waiting' });
});

// çˆ¶é¡µï¼šå–ç»“æœï¼ˆéœ€è¦ç™»å½•ï¼›åªèƒ½å–è‡ªå·± tokenï¼‰
app.get('/api/wf/result', assertAuth, (req, res) => {
  const uid = req.session.uid;
  const token = String(req.query.token || '');
  const it = wfStore.get(token);

  if (!it) return res.status(404).json({ ok:false, error:'NO_TASK' });
  if (it.uid !== uid) return res.status(403).json({ ok:false, error:'FORBIDDEN' });

  res.json({ ok:true, text: it.textOut || '' });
});


// åˆ—å‡ºå½“å‰ç”¨æˆ·çš„ slotsï¼ˆç”¨äºâ€œç”Ÿæˆé˜Ÿåˆ—â€åˆ—è¡¨ï¼‰
app.get('/api/slots', assertAuth, (req, res) => {
  const uid = req.session.uid;
  const rows = slotListByUser(uid);
  const now = Date.now();

  const items = rows.map(r => {
    const terminal = (r.status === 'done' || r.status === 'error');

    const hbTs     = r.hb_last_at ? (Date.parse(r.hb_last_at) || null) : null;
    const openedTs = r.opened_at  ? (Date.parse(r.opened_at)  || null) : null;
    const endedTs  = terminal     ? (Date.parse(r.updated_at) || null) : null;

    // ç»ˆæ€æ—¶ä¸å†æ˜¾ç¤ºâ€œè·ä¸Šæ¬¡å¿ƒè·³â€
    const hb_age_ms = (terminal || !hbTs) ? null : Math.max(0, now - hbTs);

    // è¿è¡Œæ—¶é•¿ï¼šç»ˆæ€å›ºå®šä¸º ended - openedï¼Œéç»ˆæ€ä¸º now - opened
    let runtime_ms = null;
    if (openedTs) {
      const endPoint = (terminal && endedTs) ? endedTs : now;
      runtime_ms = Math.max(0, endPoint - openedTs);
    }

    // ä¸ºäº†å…¼å®¹è€å‰ç«¯ï¼Œopen_age_ms = runtime_msï¼›æ–°å¢ ended_atã€terminal
    return Object.assign({}, r, {
      hb_age_ms,
      opened_at: r.opened_at,
      open_age_ms: runtime_ms,
      runtime_ms,
      ended_at: terminal ? r.updated_at : null,
      terminal
    });
  });

  res.json({ ok:true, items });
});

function buildPathCandidates({ rawPath, baseURL }) {
  const norm = p => {
    if (!p) return '/';
    let s = String(p).trim();
    s = s.replace(/\/+/g, '/');
    if (!s.startsWith('/')) s = '/' + s;
    return s;
  };

  const candidates = new Set();

  // åŸå§‹ pathï¼Œä¸€å®šè¦å…ˆè¯•ä¸€é
  if (rawPath) candidates.add(norm(rawPath));

  // å°è¯•å‰ªæ‰ baseURL çš„ pathname å‰ç¼€ï¼ˆæ¯”å¦‚ "/zh"ï¼‰
  try {
    if (baseURL) {
      const bu = new URL(baseURL);
      const basePath = bu.pathname.replace(/\/+$/,''); // "/zh" or ""
      if (basePath && rawPath && rawPath.startsWith(basePath)) {
        const stripped = rawPath.slice(basePath.length) || '/';
        candidates.add(norm(stripped));
      }
    }
  } catch (_) {
    // baseURL è§£æå¤±è´¥å°±å¿½ç•¥
  }

  // ç‰¹åˆ¤ rootï¼šæœ‰äº›å®ä¾‹ root ä¼šæ˜¯ "/"ï¼Œæœ‰äº›æ˜¯ "/(root)"
  for (const p of [...candidates]) {
    if (p === '/' || p === '/(root)') {
      candidates.add('/');
      candidates.add('/(root)');
    }
  }

  return [...candidates];
}


function extractWikiPath({ url, pathFromBody, baseURL }) {
  let pagePath = pathFromBody;

  if (!pagePath) {
    if (!url) return null;
    let u;
    try {
      u = new URL(url);
    } catch (_) {
      return null;
    }
    pagePath = u.pathname || '/';

    // æŠŠ query / hash å»æ‰
    pagePath = pagePath.split('?')[0].split('#')[0];
  }

  // ç”¨ wiki_base_url å»æ‰å‰ç¼€ï¼Œæ¯”å¦‚ï¼š
  // baseURL = https://wiki.aialra.online/zh
  // url    = https://wiki.aialra.online/zh/(root)
  // => pagePath åº”è¯¥å˜æˆ "/(root)"
  try {
    if (baseURL) {
      const bu = new URL(baseURL);
      let basePath = bu.pathname.replace(/\/+$/,''); // "/zh" æˆ– ""
      if (basePath && basePath !== '/' && pagePath.startsWith(basePath + '/')) {
        pagePath = pagePath.slice(basePath.length) || '/';
      } else if (basePath && basePath === pagePath) {
        // åˆšå¥½å°±æ˜¯ "/zh" æœ¬èº«
        pagePath = '/';
      }
    }
  } catch (_) {
    // baseURL é…ç½®é”™äº†å°±å¿½ç•¥è¿™æ­¥
  }

  // è§„èŒƒåŒ–
  if (!pagePath) pagePath = '/';
  pagePath = pagePath.replace(/\/+/g, '/');
  if (!pagePath.startsWith('/')) pagePath = '/' + pagePath;

  return pagePath;
}

async function loadWikiPageForUser(uid, { url, path: pathFromBody }) {
  // 1. è¯»ç”¨æˆ·é…ç½®
  const st = db.prepare('SELECT * FROM user_settings WHERE user_id=?').get(uid) || {};
  const gqlURL  = st.wiki_graphql_url || DEFAULT_WIKI_GRAPHQL;
  const baseURL = st.wiki_base_url    || DEFAULT_WIKI_BASE;
  const token   = st.wiki_token_cipher ? dec(st.wiki_token_cipher) : null;

  if (!token) {
    const err = new Error('NO_TOKEN');
    err.code = 'NO_TOKEN';
    throw err;
  }

  // 2. æå– path å¹¶ç”Ÿæˆå€™é€‰ path åˆ—è¡¨
  const rawPath = extractWikiPath({ url, pathFromBody, baseURL });
  if (!rawPath) {
    const err = new Error('BAD_URL_OR_PATH');
    err.code = 'BAD_URL_OR_PATH';
    throw err;
  }
  const candidates = buildPathCandidates({ rawPath, baseURL });

  // 3. å…ˆ list å‡ºæ‰€æœ‰é¡µé¢ï¼ˆåªç”¨ limit + orderByï¼Œschema ä¸€å®šæ”¯æŒï¼‰
  const listQuery = `
    query($limit:Int!) {
      pages {
        list(orderBy: TITLE, orderByDirection: ASC, limit:$limit) {
          id
          path
          title
        }
      }
    }`;
  const listData = await gqlRequest(gqlURL, token, listQuery, { limit: 2000 });
  const list = listData?.data?.pages?.list || [];

  // 4. åœ¨ list é‡Œæ‰¾å’Œå€™é€‰ path åŒ¹é…çš„é‚£ä¸€æ¡
  let hit = null;
  for (const cand of candidates) {
    hit = list.find(p => (p.path || '') === cand);
    if (hit) break;
  }

  if (!hit) {
    return { page: null, baseURL, candidates };
  }

  // 5. å†ç”¨ single(id: Int!) æ‹‰æ­£æ–‡ â€”â€” è¿™ä¸ªåœ¨æ‰€æœ‰ Wiki.js ç‰ˆæœ¬é‡Œéƒ½æœ‰
  const byIdQuery = `
    query($id:Int!) {
      pages {
        single(id:$id) {
          id
          path
          title
          content
        }
      }
    }`;
  const singleData = await gqlRequest(gqlURL, token, byIdQuery, { id: Number(hit.id) });
  const page = singleData?.data?.pages?.single || null;

  return { page, baseURL, candidates };
}

// è¯»å–å•ä¸ªé¡µé¢åŸå§‹å†…å®¹ï¼ˆç»™â€œåŒæ­¥æ¨¡æ¿â€ç­‰ç”¨ï¼‰
// body: { url?: string, path?: string }
// è¿”å›: { ok:true, page:{ id, path, title, content } }
// ä» Wiki.js è¯»å–å•ä¸ªé¡µé¢å†…å®¹
// çº¦å®šï¼š
//   - body.url   å¯é€‰ï¼Œå®Œæ•´é¡µé¢ URLï¼Œä¾‹å¦‚ https://wiki.example.com/zh/(root)
//   - body.path  å¯é€‰ï¼Œä¼˜å…ˆçº§é«˜äº urlï¼Œä¾‹å¦‚ /zh/(root)
// è¿”å›ï¼š{ ok:true, page:{ id, path, title, content } }
// è¯»å–å•ä¸ªé¡µé¢å†…å®¹ï¼ˆæ–°ç‰ˆï¼‰
// body: { url?: string, path?: string }
// è¯»å–å•ä¸ªé¡µé¢ï¼ˆè¿”å› id/path/title/contentï¼‰
app.post('/api/wiki/get', verifyCSRF, assertAuth, async (req, res) => {
  const uid = req.session.uid;
  const { url, path: pathFromBody } = req.body || {};

  try {
    const { page } = await loadWikiPageForUser(uid, { url, path: pathFromBody });

    if (!page) {
      return res.status(404).json({ ok:false, error:'NOT_FOUND' });
    }

    return res.json({
      ok: true,
      page: {
        id: page.id,
        path: page.path,
        title: page.title,
        content: page.content || ''
      }
    });
  } catch (e) {
    console.error('[wiki.get] FAIL', e);

    if (e.code === 'NO_TOKEN') {
      return res.status(400).json({ ok:false, error:'NO_TOKEN' });
    }
    if (e.code === 'BAD_URL_OR_PATH') {
      return res.status(400).json({ ok:false, error:'BAD_URL_OR_PATH' });
    }

    return res.status(500).json({
      ok: false,
      error: 'GQL_FAIL',
      message: String(e?.message || e)
    });
  }
});



// å…¼å®¹è€å‰ç«¯ï¼šåªè¦æ­£æ–‡
// body: { url?: string, path?: string }
// è¿”å›ï¼š{ ok:true, title, path, content, id }
// å…¼å®¹è€å‰ç«¯ï¼šåªè¦æ­£æ–‡ï¼ˆcontentï¼‰ï¼Œå…¶ä½™ä¿¡æ¯æ”¾ meta
app.post('/api/wiki/get-content', verifyCSRF, assertAuth, async (req, res) => {
  const uid = req.session.uid;
  const { url, path: pathFromBody } = req.body || {};

  try {
    const { page } = await loadWikiPageForUser(uid, { url, path: pathFromBody });

    if (!page) {
      return res.status(404).json({ ok:false, error:'NOT_FOUND' });
    }

    return res.json({
      ok: true,
      content: page.content || '',
      meta: {
        id: page.id,
        path: page.path,
        title: page.title
      }
    });
  } catch (e) {
    console.error('[wiki.get-content] FAIL', e);

    if (e.code === 'NO_TOKEN') {
      return res.status(400).json({ ok:false, error:'NO_TOKEN' });
    }
    if (e.code === 'BAD_URL_OR_PATH') {
      return res.status(400).json({ ok:false, error:'BAD_URL_OR_PATH' });
    }

    return res.status(500).json({
      ok: false,
      error: 'GQL_FAIL',
      message: String(e?.message || e)
    });
  }
});





app.post('/api/slots/pin', verifyCSRF, assertAuth, (req, res) => {
  const uid = req.session.uid;
  const { token, pinned } = req.body || {};
  if (!token) return res.status(400).json({ ok:false, error:'BAD_REQUEST' });

  const row = db.prepare('SELECT user_id FROM wf_slots WHERE token=?').get(String(token));
  if (!row) return res.status(404).json({ ok:false, error:'NOT_FOUND' });
  if (row.user_id !== uid) return res.status(403).json({ ok:false, error:'FORBIDDEN' });

  if (pinned) {
    // ç‹¬å ç½®é¡¶ï¼šå…ˆæ¸…æ‰è¯¥ç”¨æˆ·å…¶ä»– pinned
    db.prepare('UPDATE wf_slots SET pinned=0 WHERE user_id=?').run(uid);
    db.prepare('UPDATE wf_slots SET pinned=1, updated_at=CURRENT_TIMESTAMP WHERE token=? AND user_id=?')
      .run(String(token), uid);
    // ç«‹åˆ»ç»™è¿™ä¸ª token ä¸€æ¬¡æ€§èšç„¦
    const it = wfStore.get(String(token));
    if (it) it.poke = 'focus';
  } else {
    db.prepare('UPDATE wf_slots SET pinned=0, updated_at=CURRENT_TIMESTAMP WHERE token=? AND user_id=?')
      .run(String(token), uid);
  }
  res.json({ ok:true });
  try { sseBroadcast(uid, 'slots_changed', { token: String(token), pinned: !!pinned }); } catch (_) {}

 });

// è¯»å–å•ä¸ª slot è¯¦æƒ…ï¼ˆå« text_in/outï¼‰ï¼Œç”¨äºå‰ç«¯é¢„è§ˆ / è¯Šæ–­
app.get('/api/slots/:token', assertAuth, (req, res) => {
  const uid = req.session.uid;
  const t = String(req.params.token || '');
  const row = slotGetByToken(t);
  if (!row) return res.status(404).json({ ok:false, error:'NOT_FOUND' });
  if (row.user_id !== uid) return res.status(403).json({ ok:false, error:'FORBIDDEN' });
  return res.json({ ok:true, slot: row });
});

// âœ… é«˜é€Ÿæ¸…ç†ï¼šä¸€æ¬¡SQLæå®šï¼ˆåªå¯¹å†…å­˜ä¸­ä»åœ¨çº¿çš„tokené€ä¸€ä¸‹å‘killï¼‰
// scope: 'all' | 'done' | 'others' | 'nonactive'
//  - all: é™¤è¿è¡Œä¸­çš„ï¼ˆpicked/runningï¼‰å¤–å…¨éƒ¨æ¸…
//  - done: ä»… done/error æ¸…
//  - others: ä»…æ¸…é™¤â€œéå½“å‰ç½®é¡¶&éè¿è¡Œä¸­â€çš„æ¡ç›®ï¼ˆå…¸å‹â€œåªä¿ç•™æ­£åœ¨ç”Ÿæˆçš„çª—â€ï¼‰
//  - nonactive: æ¸…é™¤éè¿è¡Œæ€ï¼ˆä¸æ˜¯ picked/runningï¼‰
app.post('/api/slots/clear', verifyCSRF, assertAuth, (req, res) => {
  const uid = req.session.uid;
  const scope = String(req.body?.scope || 'done');

  // æ„é€ å¾…åˆ é™¤çš„tokené›†åˆï¼ˆå†æ‰¹é‡DELETEï¼‰
  let cond = '', params = [uid];
  if (scope === 'done') {
    cond = "status IN ('done','error')";
  } else if (scope === 'all') {
    cond = "status NOT IN ('picked','running')";
  } else if (scope === 'others') {
    // ä¿ç•™å½“å‰ç½®é¡¶ + è¿è¡Œæ€ï¼›æ¸…ç†å…¶ä½™
    cond = "NOT (pinned=1 OR status IN ('picked','running'))";
  } else if (scope === 'nonactive') {
    cond = "status NOT IN ('picked','running')";
  } else {
    return res.status(400).json({ ok:false, error:'BAD_SCOPE' });
  }

  const toDel = db.prepare(
    `SELECT token FROM wf_slots WHERE user_id=? AND ${cond}`
  ).all(uid).map(r => String(r.token));

  if (toDel.length) {
    const tx = db.transaction((ids)=>{
      // æ‰¹é‡åˆ é™¤
      const mark = db.prepare('DELETE FROM wf_slots WHERE user_id=? AND token=?');
      for (const t of ids) mark.run(uid, t);
    });
    tx(toDel);
  }

  // æ€æ‰ä»åœ¨çº¿çš„å­é¡µï¼ˆä»…é’ˆå¯¹è¢«åˆ tokenï¼›O(n) = åœ¨çº¿çª—å£æ•°ï¼‰
  for (const t of toDel) {
    const it = wfStore.get(t);
    if (it && it.uid === uid) {
      it.kill = true;
      it.state = 'error';
      it.textOut = 'deleted-by-user';
      it.ts = Date.now();
    }
  }
  res.json({ ok:true, deleted: toDel.length });
  try { sseBroadcast(uid, 'slots_changed', { scope, deleted: toDel.length }); } catch (_) {}

});


// åˆ é™¤å•ä¸ª slotï¼ˆæäº¤æˆåŠŸåè°ƒç”¨ï¼‰
app.delete('/api/slots/:token', verifyCSRF, assertAuth, (req, res) => {
  const uid = req.session.uid;
  slotDelete(String(req.params.token||''), uid);
  res.json({ ok:true });
});


// å…œåº• 404ï¼ˆAPIï¼‰
app.use('/api/', (req,res)=>res.status(404).json({ ok:false, error:'API_NOT_FOUND' }));

// ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶æ£€æŸ¥å¯†é’¥
if (NODE_ENV === 'production') {
  if (SESSION_SECRET.startsWith('dev_') || APP_KEY.startsWith('dev_')) {
    console.error('FATAL: SESSION_SECRET / APP_KEY æœªé…ç½®ä¸ºå®‰å…¨å€¼');
    process.exit(1);
  }
}

// å¯åŠ¨
app.listen(PORT, () => {
  console.log(`[wikiflow] listening on :${PORT}`);
});

